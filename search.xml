<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dubbo SPI 扩展实现测试]]></title>
    <url>%2F2019%2F06%2F08%2Fdubbo-spi-test%2F</url>
    <content type="text"><![CDATA[Dubbo SPI 测试 Dubbo 提供了类似 JDK 标准 SPI(Service Provider Interface)的一套服务扩展实现，而且有所加强，官方文档 JDK 标准 SPI 会主动实例化扩展点的所有实现，如果扩展点初始化很耗时，而且如果该扩展点被加载后不使用，也是资源浪费 通过 setter 方式，实现了 IOC &amp; AOP ExtensionLoader Code Comments12345678910111213141516171819202122232425262728293031323334// Key:接口,Value: 接口对应的ExtensionLoder实例private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;&gt;();// Key:接口, Value:接口实现类的实例private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;&gt;();// ==========以下是 ExtensionLoader 类成员变量====================// 需要扩展的接口类型private final Class&lt;?&gt; type;// 具体的扩展对象工厂，ExtensionFactory 自己的扩展的对象工厂为nullprivate final ExtensionFactory objectFactory;// 接口的所有扩展类private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;&gt;();private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;&gt;();// 缓存的自动激活的扩展点private final Map&lt;String, Object&gt; cachedActivates = new ConcurrentHashMap&lt;&gt;();// 扩展的对象实例private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;&gt;();// 自适应扩展类最多只允许有一个private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;&gt;();// 自适应扩展类最多只允许有一个private volatile Class&lt;?&gt; cachedAdaptiveClass = null;private String cachedDefaultName;// Wrapper 类，可以有多个,达到Wrapper 的 Wrapper ...的效果private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses ExtensionLoader 的简单测试HelloService 接口 123456789101112131415package com.lankio.learning.dubbo;import org.apache.dubbo.common.URL;import org.apache.dubbo.common.extension.Adaptive;import org.apache.dubbo.common.extension.SPI;@SPI(&quot;dennis&quot;)public interface HelloService &#123; String sayHello(String hello); @Adaptive String sayHello(URL url, String hello);&#125; HelloService 接口的普通实现 1234567891011121314public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String hello) &#123; return &quot;Hello! &quot; + hello; &#125; @Override public String sayHello(URL url, String hello) &#123; return url + &quot;, Hello! &quot; + hello; &#125;&#125; HelloService 接口的自适应扩展实现 12345678910111213141516@Adaptive // Annotation mustpublic class AdaptiveHelloServiceImpl implements HelloService &#123; @Override public String sayHello(String hello) &#123; return ExtensionLoader.getExtensionLoader(HelloService.class).getDefaultExtension().sayHello(hello); &#125; @Override public String sayHello(URL url, String hello) &#123; return ExtensionLoader.getExtensionLoader(HelloService.class).getDefaultExtension().sayHello(url, hello); &#125;&#125; 同时提供两个 HelloService 的 Wrapper 实现，输出效果：Wrapper2 [Wrapper1 [Hello! DENNIS]] 1234567891011121314151617181920212223242526272829303132333435363738394041public class HelloService1Wrapper implements HelloService &#123; private HelloService helloService; public HelloService1Wrapper(HelloService helloService) &#123; this.helloService = helloService; &#125; @Override public String sayHello(String hello) &#123; return &quot;Wrapper1 [&quot; + helloService.sayHello(hello) + &quot;]&quot;; &#125; @Override public String sayHello(URL url, String hello) &#123; return &quot;Wrapper1 [&quot; + helloService.sayHello(url, hello) + &quot;]&quot;; &#125;&#125;public class HelloService2Wrapper implements HelloService &#123; private HelloService helloService; public HelloService2Wrapper(HelloService helloService) &#123; this.helloService = helloService; &#125; @Override public String sayHello(String hello) &#123; return &quot;Wrapper2 [&quot; + helloService.sayHello(hello) + &quot;]&quot;; &#125; @Override public String sayHello(URL url, String hello) &#123; return &quot;Wrapper2 [&quot; + helloService.sayHello(url, hello) + &quot;]&quot;; &#125;&#125; 配置文件 META-INF/dubbo/com.lankio.learning.dubbo.HelloService 1234567891011# HelloService 默认扩展实现dennis=com.lankio.learning.dubbo.service.HelloServiceImpl# 人工手动实现的自适应扩展实现，注释掉该实现，ExtensionLoader.getExtensionLoader(HelloService.class).getAdaptiveExtension() 会# 自动生成自适应扩展实现adaptive=com.lankio.learning.dubbo.service.AdaptiveHelloServiceImpl# Wrapper 实现了类似 AOP 的功能wrapper1=com.lankio.learning.dubbo.service.HelloService1Wrapperwrapper2=com.lankio.learning.dubbo.service.HelloService2Wrapper ExtensionLoader 测试 123456789101112131415161718192021222324public class ExtensionLoaderTest &#123; public static void main(String[] args) &#123; // test auto-active extension URL url = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, 8080, HelloService.class.getCanonicalName()).addParameter(&quot;filter&quot;, &quot;-cache,-echo,-trace,-timeout&quot;); List&lt;Filter&gt; activeFilters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(url, &quot;filter&quot;); System.out.println(String.format(&quot;auto-active %d Filters as follows:&quot;, activeFilters.size())); activeFilters.forEach(s -&gt; System.out.println(&quot;\t&quot; + s)); // General service implement HelloService helloService = ExtensionLoader.getExtensionLoader(HelloService.class).getExtension(&quot;dennis&quot;); System.out.println(helloService.getClass().getCanonicalName()); System.out.println(helloService.sayHello(&quot;DENNIS&quot;)); // Adaptive service implement helloService = ExtensionLoader.getExtensionLoader(HelloService.class).getAdaptiveExtension(); System.out.println(helloService.getClass().getCanonicalName()); System.out.println(helloService.sayHello(new URL(&quot;file&quot;, &quot;/home&quot;, 0), &quot;DENNIS&quot;)); &#125;&#125; 总结 ExtensionLoder 是个对象工厂，每个接口对应一个ExtensionLoder实例，缓存在ExtensionLoder的静态变量中（成员变量中也有缓存容器)，而且只有使用到接口的实现时才会主动创建具体的接口实例 自动激活的扩展实现，通常有多个实现，列如 Filter, Listener 等，可以根据 URL 参数自动激活指定实现]]></content>
      <categories>
        <category>dubbo</category>
        <category>code-reading</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
</search>
