<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dubbo-spi-adaptive]]></title>
    <url>%2F2019%2F06%2F10%2Fdubbo-spi-adaptive%2F</url>
    <content type="text"><![CDATA[Dubbo SPI- Adaptive 笔记 Dubbo SPI Adaptive 类型的扩展有两种方式 1. 手工编写的 Adaptive 扩展类，如果有提供，则不会自动生成扩展类， 即优先级高于第二种配置文件(文件名必须与类的全名相同) META-INF/dubbo/com.yiyiers.learning.dubbo.HelloService123456# HelloService 普通扩展实现hello1=com.yiyiers.learning.dubbo.service.HelloServiceImplhello2=com.yiyiers.learning.dubbo.service.HelloServiceImpl2# 人工手动实现的自适应扩展实现， 因为只能有一个自适应扩展实现，name 其实可以没有，最好还要有，比较清晰adaptive=com.yiyiers.learning.dubbo.service.AdaptiveHelloServiceImpl AdaptiveHelloServiceImpl 扩展实现类必须有注解 @Adaptive, Demo 实现细节无关1234567891011121314@Adaptive // Annotation mustpublic class AdaptiveHelloServiceImpl implements HelloService &#123; @Override public String sayHello(String hello) &#123; return ExtensionLoader.getExtensionLoader(HelloService.class).getDefaultExtension().sayHello(hello); &#125; @Override public String sayHello(URL url, String hello) &#123; return ExtensionLoader.getExtensionLoader(HelloService.class).getDefaultExtension().sayHello(url, hello); &#125; 2. Dubbo 自动生成的 Adaptive 扩展类接口方法 有 @Adaptive 注解的才会自动生成代理方法，没有@Adaptive 注解的方法不支持通过自适应扩展实现调用12345678910111213141516171819@SPI(&quot;hello1&quot;)public interface HelloService &#123; // 该方法不支持自适应扩展调用 String sayHello(String hello); /** * 1. 注解 @Adaptive 的 value 作为 url 的 key， key对应的值作为扩展名称，用来查找具体的扩展实现类 * 2. 如果 url = dubbo://127.0.0.1/xxx.yyyy.Serivce?hello.ext=hello2，则会使用 hello2 这个扩展实现的方法执行 * 3. 如果 url 没有指定 hello.ext 的值，则使用默认的扩展实现hello1 * * @param url * @param hello * @return */ //@Adaptive @Adaptive(&quot;hello.ext&quot;) String sayHello(URL url, String hello);&#125; 自动生成的自适应扩展类的类名尾部都是 $Adaptive, Demo as follows:123456789101112131415161718192021222324package com.yiyiers.learning.dubbo;import org.apache.dubbo.common.extension.ExtensionLoader;public class HelloService$Adaptive implements com.yiyiers.learning.dubbo.HelloService &#123; public java.lang.String sayHello(java.lang.String arg0) &#123; throw new UnsupportedOperationException( &quot;The method public abstract java.lang.String com.yiyiers.learning.dubbo.HelloService.sayHello(java.lang.String) of interface com.yiyiers.learning.dubbo.HelloService is not adaptive method!&quot;); &#125; public java.lang.String sayHello(org.apache.dubbo.common.URL arg0, java.lang.String arg1) &#123; if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;); org.apache.dubbo.common.URL url = arg0; String extName = url.getParameter(&quot;hello.ext&quot;, &quot;hello1&quot;); if (extName == null) throw new IllegalStateException( &quot;Failed to get extension (com.yiyiers.learning.dubbo.HelloService) name from url (&quot; + url.toString() + &quot;) use keys([hello.ext])&quot;); com.yiyiers.learning.dubbo.HelloService extension = (com.yiyiers.learning.dubbo.HelloService) ExtensionLoader .getExtensionLoader(com.yiyiers.learning.dubbo.HelloService.class).getExtension(extName); return extension.sayHello(arg0, arg1); &#125;&#125;]]></content>
      <categories>
        <category>dubbo</category>
        <category>code-reading</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>SPI</tag>
        <tag>SPI-adaptive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo SPI 扩展实现测试]]></title>
    <url>%2F2019%2F06%2F08%2Fdubbo-spi-test%2F</url>
    <content type="text"><![CDATA[Dubbo-2.7.1 SPI 测试 Dubbo 提供了类似 JDK 标准 SPI(Service Provider Interface)的一套服务扩展实现，而且有所加强，官方文档 JDK 标准 SPI 会主动实例化扩展点的所有实现，如果扩展点初始化很耗时，而且如果该扩展点被加载后不使用，也是资源浪费 通过 setter 方式，实现了 IOC &amp; AOP ExtensionLoader Code Comments1234567891011121314151617181920212223242526272829303132333435// Key:接口,Value: 接口对应的ExtensionLoder实例private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;&gt;();// Key:接口的实现类, Value:接口实现类的实例private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;&gt;();// ==========以下是 ExtensionLoader 类成员变量====================// 需要扩展的接口类型private final Class&lt;?&gt; type;// 具体的扩展对象工厂，ExtensionFactory 自己的扩展的对象工厂为nullprivate final ExtensionFactory objectFactory;// Key:接口实现类, Value:实现类的名称（name）private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;&gt;();// Key:实现类的名称（name）, Value: 接口的实现类；和 cachedNames key-value 调换了一下private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;&gt;();// 缓存的自动激活的扩展点,Key: 接口实现类的名称（name）, Value: @Activate的配置实例private final Map&lt;String, Object&gt; cachedActivates = new ConcurrentHashMap&lt;&gt;();// 扩展的对象实例private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;&gt;();// 自适应扩展类最多只允许有一个private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;&gt;();// 自适应扩展类最多只允许有一个private volatile Class&lt;?&gt; cachedAdaptiveClass = null;private String cachedDefaultName;// Wrapper 类，可以有多个,达到Wrapper 的 Wrapper ...的效果private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses ExtensionLoader 的简单测试HelloService 接口 123456789101112131415package com.yiyiers.learning.dubbo;import org.apache.dubbo.common.URL;import org.apache.dubbo.common.extension.Adaptive;import org.apache.dubbo.common.extension.SPI;@SPI(&quot;dennis&quot;)public interface HelloService &#123; String sayHello(String hello); @Adaptive String sayHello(URL url, String hello);&#125; HelloService 接口的普通实现 1234567891011121314public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String hello) &#123; return &quot;Hello! &quot; + hello; &#125; @Override public String sayHello(URL url, String hello) &#123; return url + &quot;, Hello! &quot; + hello; &#125;&#125; HelloService 接口的自适应扩展实现 12345678910111213141516@Adaptive // Annotation mustpublic class AdaptiveHelloServiceImpl implements HelloService &#123; @Override public String sayHello(String hello) &#123; return ExtensionLoader.getExtensionLoader(HelloService.class).getDefaultExtension().sayHello(hello); &#125; @Override public String sayHello(URL url, String hello) &#123; return ExtensionLoader.getExtensionLoader(HelloService.class).getDefaultExtension().sayHello(url, hello); &#125;&#125; 同时提供两个 HelloService 的 Wrapper 实现，输出效果：Wrapper2 [Wrapper1 [Hello! DENNIS]] 1234567891011121314151617181920212223242526272829303132333435363738394041public class HelloService1Wrapper implements HelloService &#123; private HelloService helloService; public HelloService1Wrapper(HelloService helloService) &#123; this.helloService = helloService; &#125; @Override public String sayHello(String hello) &#123; return &quot;Wrapper1 [&quot; + helloService.sayHello(hello) + &quot;]&quot;; &#125; @Override public String sayHello(URL url, String hello) &#123; return &quot;Wrapper1 [&quot; + helloService.sayHello(url, hello) + &quot;]&quot;; &#125;&#125;public class HelloService2Wrapper implements HelloService &#123; private HelloService helloService; public HelloService2Wrapper(HelloService helloService) &#123; this.helloService = helloService; &#125; @Override public String sayHello(String hello) &#123; return &quot;Wrapper2 [&quot; + helloService.sayHello(hello) + &quot;]&quot;; &#125; @Override public String sayHello(URL url, String hello) &#123; return &quot;Wrapper2 [&quot; + helloService.sayHello(url, hello) + &quot;]&quot;; &#125;&#125; 配置文件 META-INF/dubbo/com.yiyiers.learning.dubbo.HelloService 1234567891011# HelloService 默认扩展实现dennis=com.yiyiers.learning.dubbo.service.HelloServiceImpl# 人工手动实现的自适应扩展实现，注释掉该实现，ExtensionLoader.getExtensionLoader(HelloService.class).getAdaptiveExtension() 会# 自动生成自适应扩展实现adaptive=com.yiyiers.learning.dubbo.service.AdaptiveHelloServiceImpl# Wrapper 实现了类似 AOP 的功能wrapper1=com.yiyiers.learning.dubbo.service.HelloService1Wrapperwrapper2=com.yiyiers.learning.dubbo.service.HelloService2Wrapper ExtensionLoader 测试 123456789101112131415161718192021222324public class ExtensionLoaderTest &#123; public static void main(String[] args) &#123; // test auto-active extension URL url = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, 8080, HelloService.class.getCanonicalName()).addParameter(&quot;filter&quot;, &quot;-cache,-echo,-trace,-timeout&quot;); List&lt;Filter&gt; activeFilters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(url, &quot;filter&quot;); System.out.println(String.format(&quot;auto-active %d Filters as follows:&quot;, activeFilters.size())); activeFilters.forEach(s -&gt; System.out.println(&quot;\t&quot; + s)); // General service implement HelloService helloService = ExtensionLoader.getExtensionLoader(HelloService.class).getExtension(&quot;dennis&quot;); System.out.println(helloService.getClass().getCanonicalName()); System.out.println(helloService.sayHello(&quot;DENNIS&quot;)); // Adaptive service implement helloService = ExtensionLoader.getExtensionLoader(HelloService.class).getAdaptiveExtension(); System.out.println(helloService.getClass().getCanonicalName()); System.out.println(helloService.sayHello(new URL(&quot;file&quot;, &quot;/home&quot;, 0), &quot;DENNIS&quot;)); &#125;&#125; 总结 ExtensionLoader 是个对象工厂，每个接口对应一个ExtensionLoader 实例，缓存在 ExtensionLoader 的静态变量中（成员变量中也有缓存容器)，而且只有使用到接口的实现时才会主动创建具体的接口实例 自动激活的扩展实现，通常有多个实现，列如 Filter, Listener 等，可以根据 URL 参数自动激活指定实现]]></content>
      <categories>
        <category>dubbo</category>
        <category>code-reading</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
</search>
